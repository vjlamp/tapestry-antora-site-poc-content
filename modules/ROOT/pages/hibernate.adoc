= Hibernate Integration

The `tapestry-hibernate` module provides out-of-the-box support for using Hibernate as the back end for normal CRUD style Tapestry applications.

This represents access to the native Hibernate interfaces, exposed in a thread-safe manner, within a _session-per-request_ strategy.

Note that a number of the more esoteric ideas in Hibernate are not supported, including nested transactions and supporting multiple persistence units.

TIP: The `tapestry-hibernate-core` module allows non-web applications to access Hibernate.

== Usage
=== Entity value encoding
The Tapestry-hibernate-core module provides Value Encoder automatically for all mapped Hibernate entity types. This is done by encoding the entity as it's id (coerced to a String) and decoding the entity by looking it up in the Hibernate Session using the encoded id. Consider the following example:

Accessing the page as `/viewperson/152` would load the Person entity with id 152 and use that as the page context.

=== Using `@PageActivationContext`
If you prefer to use annotations, you may let Tapestry generate the page activation context handlers for you. Relying on an existing ValueEncoder for the corresponding property you can use the @PageActivationContext annotation. The disadvantage is that you can't access the handlers in a unit test.

=== Using `@Persist` with entities
If you wish to persist an entity in the session, you may use the "entity" persistence strategy:

This persistence strategy works with any Hibernate entity that is associated with a valid Hibernate Session by persisting only the id of the entity.
Notice that no `onPassivate()` method is needed; when the page renders the entity is loaded by the id stored in the session.

////
=== Using `@SessionState` with entities
Added in 5.2
The default strategy for persisting Session State Objects is "session".
Storing a Hibernate entity into a <HttpSession> is problematic because the stored entity is detached from the Hibernate session.
Similar to @Persist("entity") you may use the "entity" persistence strategy to persist Hibernate entities as SSOs:
For this purpose you need to set the value of the symbol <HibernateSymbols.ENTITY_SESSION_STATE_PERSISTENCE_STRATEGY_ENABLED> to <true>:

Alternatively you can apply the "entity" persistence strategy to a single Hibernate entity:
////

=== Committing Changes
All Hibernate operations occur in a transaction, but that transaction is aborted at the end of each request; thus any changes you make will be _lost_ unless the transaction is committed.

The correct way to commit the transaction is via the `@CommitAfter` annotation:

In this example, the Person object may be updated by a form; the form's success event handler method, `onSuccess()` has the `@CommitAfter` annotation.

Behind the scenes, the `@CommitAfter` annotation causes the HibernateSessionManager's `commit()` method to be executed before the method returns.

The transaction will be committed when the method completes normally.

The transaction will be _aborted_ if the method throws a `RuntimeException`.

The transaction will be *committed* if the method throws a checked exception (one listed in the throws clause of the method).

=== Managing Transactions using DAOs
As your application grows, you will likely create a Data Access Object layer between your pages and the Hibernate APIs.

The `@CommitAfter` annotation can be useful there as well.

You may use `@CommitAfter` on method of your service interface, then use a decorator to provide the transaction management logic.

First definine your DAO's service interface:

// TODO Source code is missing here

Next, define your service in your application's Module class:

// TODO Source code is missing here

Finally, you should use the `HibernateTransactionAdvisor` to add transaction advice:

// TODO Source code is missing here

This advice method is configured to match against any service whose id ends with "DAO", such as "PersonDAO".

The advisor scans the service interface and identifies any methods with the @CommitAfter annotation.

== Configuration
=== Hibernate Session Source
One way to configure hibernate is to create a `hibernate.cfg.xml` file and place it in the root of your application (i.e., under `src/main/resources`).
Most Hibernate-specific configuration occurs in this file.
Another way is to contribute objects that perform configuration (such as setting event listeners). Example:

[source,java]
----
public static void contributeHibernateSessionSource(OrderedConfiguration<HibernateConfigurer> config)
{
  config.add("Widget", new WidgetHibernateConfigurer());
}
----
Note that the configuration is an javadoc:org.apache.tapestry5.ioc.OrderedConfiguration[]. The library contributes two configurers by default:

* `Default` - performs default hibernate configuration
* `PackageName` - loads entities by package name as contributed to the javadoc:org.apache.tapestry5.hibernate.HibernateEntityPackageManager[] service

=== HibernateEntityPackageManager Configuration
This configuration is a set of package names, identifying where to search for entity classes.

For each package contributed, the library will:

* Add the package to the configuration, which will load annotations from the package-info class within the named package, if present.
* Every Java class in the package (or any subpackage) will be added as an annotated class. This excludes inner classes, but includes all other classes.

By default, the package _application-root-package.entities_ is scanned as described above.
If you have additional packages containing entities, you must contribute them to the tapestry.hibernate.HibernateEntityPackageManager service configuration, like so:

[source,java]
----
public static void contributeHibernateEntityPackageManager(Configuration<String> configuration)
{
  configuration.add("org.example.myapp.domain");
}
----

You may add as many packages in this manner as you wish.
This option is most often used when the entities themselves are contained in a library included within an application, rather than part of the application directly.

=== Hibernate Symbols
The Hibernate integration includes a number of symbols used to control certain features:

tapestry.hibernate.provide-entity-value-encoders:: If `true` (the default) then ValueEncoders are automatically provided for all Hibernate entities (ValueEncoders are used to encode the primary keys of entities as strings that can be included in URLs). Set to false if you want direct control over this feature.
tapestry.hibernate.default-configuration:: If `true` (the default), then the application must include a `hibernate.cfg.xml` file. If your application configures itself entirely in code, you should set this symbol to false.
tapestry.hibernate.early-startup:: If `true`, the Hibernate is initialized when the application starts up. The default is `false`, to start Hibernate up lazily, on first use.
== Licensing Issues
Hibernate is licensed under the Lesser GNU Public License.
This is more restrictive license than the Apache Software License used by the rest of Tapestry.
The restrictions mostly apply to redistributing Hibernate, especially in any altered form, and will likely be irrelevant to the vast majority of users, but you should be aware.

== Hibernate Statistics
If you enable Hibernate statistics by setting the property `hibernate.generate_statistics` to `true`, Hibernate will expose a number of useful metrics.
The page "Statistics" is used to expose these metrics. This page is only available in development mode.
